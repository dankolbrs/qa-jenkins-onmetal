#!/usr/bin/env groovy


def wait_for_ping(host_ip, timeout_sec) {

    echo "Waiting for the host with IP:${host_ip} to become online."
    def response
    def current_time
    def initial_time = sh returnStdout: true, script: 'date +%s'
    waitUntil {
        current_time = sh returnStdout: true, script: 'date +%s'
        if (current_time.toInteger() - initial_time.toInteger() > timeout_sec.toInteger()) {
            error "The host did not respond to ping within the timeout of ${timeout} seconds"
        }
        response = sh returnStatus: true, script: "ping -q -c 1 ${host_ip}"
        return (response == 0)
    }

}


def onmetal_provision(datacenter_tag) {

    // Spin onMetal Server
    echo 'Running the following playbook: build_onmetal'
    ansiblePlaybook playbook: 'build_onmetal.yaml', sudoUser: null, tags: "${datacenter_tag}"

    // Verify onMetal server data
    echo 'Running the following playbook: get_onmetal_facts'
    ansiblePlaybook inventory: 'hosts', playbook: 'get_onmetal_facts.yaml', sudoUser: null, tags: "${datacenter_tag}"

    // Get server IP address
    String hosts = readFile("hosts")
    String ip = hosts.substring(hosts.indexOf('=')+1).replaceAll("[\n\r]", "")

    // Wait for server to become active
    wait_for_ping(ip, 600)

    // Prepare OnMetal server, retry up to 5 times for the command to work
    echo 'Running the following playbook: prepare_onmetal'
    retry(5) {
        ansiblePlaybook inventory: 'hosts', playbook: 'prepare_onmetal.yaml', sudoUser: null
    }

    // Apply CPU fix - will restart server (~5 min)
    echo 'Running the following playbook: set_onmetal_cpu'
    ansiblePlaybook inventory: 'hosts', playbook: 'set_onmetal_cpu.yaml', sudoUser: null

    // Wait for the server to come back online
    wait_for_ping(ip, 600)

    return (ip)

}


def vm_provision() {

    // Configure VMs onMetal server
    echo 'Running the following playbook: configure_onmetal'
    ansiblePlaybook inventory: 'hosts', playbook: 'configure_onmetal.yaml', sudoUser: null

    // Create VMs where OSA will be deployed
    echo 'Running the following playbook: create_lab'
    ansiblePlaybook inventory: 'hosts', playbook: 'create_lab.yaml', sudoUser: null

}


def vm_preparation_for_osa() {

    // Prepare each VM for OSA installation
    echo 'Running the following playbook: prepare_for_osa'
    ansiblePlaybook inventory: 'hosts', playbook: 'prepare_for_osa.yaml', sudoUser: null

}


def deploy_openstack() {
    
    echo 'Running the following playbook: deploy_osa'
    ansiblePlaybook inventory: 'hosts', playbook: 'deploy_osa.yaml', sudoUser: null

}


def configure_tempest(host_ip) {

    String remote_location

    // Add a script to the provisioner for installing and configuring Tempest
    writeFile file: 'configure_tempest.sh', text: '''#!/bin/bash
git clone https://github.com/openstack/tempest.git /root/tempest
cd /root/tempest/
pip install -r requirements.txt
cd /root/tempest/etc/
wget https://raw.githubusercontent.com/CasJ/openstack_one_node_ci/master/tempest.conf
# Get the configuration file generated by OSA
scp infra01_utility:/opt/tempest_untagged/etc/tempest.conf /root/tempest/etc/tempest.conf.osa
# Configure tempest based on the OSA deployment
keys="admin_password image_ref image_ref_alt uri uri_v3 public_network_id reseller_admin_role"
for key in \$keys
do
a="\${key} ="
sed -ir "s|\$a.*|\$a|g" /root/tempest/etc/tempest.conf
b=`cat /root/tempest/etc/tempest.conf.osa | grep "\$a"`
sed -ir "s|\$a|\$b|g" /root/tempest/etc/tempest.conf
done'''
    
    // Copy a random file first to make sure the system is accesible
    try {	
    	sh "scp -o StrictHostKeyChecking=no hosts root@${host_ip}:/root/hosts"
    } catch(Exception ex) {
        echo 'Expected exception catched. System not yet available.'
    }

    // Copy the script to the onMetal host
    remote_location = "root@${host_ip}:/root/configure_tempest.sh"
    sh """
    chmod +x configure_tempest.sh
    scp -o StrictHostKeyChecking=no configure_tempest.sh ${remote_location}
    """

    // Run the script in the remote host
    sh """
    ssh -o StrictHostKeyChecking=no root@${host_ip} '''
    ./configure_tempest.sh
    '''
    """

}


def run_tempest_smoke_tests(host_ip) {

    String remote_location

    // Add a script to the provisioner for running Tempest
    writeFile file: 'run_tempest.sh', text: '''#!/bin/bash
#!/bin/bash
mkdir /root/subunit
cd /root/tempest/
# Run the tests and store the results in ~/subunit/before
testr init
stream_id=`cat .testrepository/next-stream`
ostestr --no-slowest --regex smoke
cp .testrepository/\$stream_id /root/subunit/before
'''

    // Copy the script to the onMetal host
    remote_location = "root@${host_ip}:/root/run_tempest.sh"
    sh """
    chmod +x run_tempest.sh
    scp -o StrictHostKeyChecking=no run_tempest.sh ${remote_location}
    """

    // Run the tests and store the results in ~/subunit/before
    sh """
    ssh -o StrictHostKeyChecking=no root@${host_ip} '''
    ./run_tempest.sh
    '''
    """
    
}


def delete_virtual_resources() {

    echo 'Running the following playbook: destroy_virtual_machines'
    ansiblePlaybook inventory: 'hosts', playbook: 'destroy_virtual_machines.yaml', sudoUser: null
    echo 'Running the following playbook: destroy_virtual_networks'
    ansiblePlaybook inventory: 'hosts', playbook: 'destroy_virtual_networks.yaml', sudoUser: null
    echo 'Running the following playbook: destroy_lab_state_file'
    ansiblePlaybook inventory: 'hosts', playbook: 'destroy_lab_state_file.yaml', sudoUser: null

}


def delete_onmetal(onmetal_ip, datacenter_tag) {

    echo 'Running the following playbook: destroy_onmetal'
    ansiblePlaybook inventory: 'hosts', playbook: 'destroy_onmetal.yaml', sudoUser: null, tags: "${datacenter_tag}"

    sh """
    ssh-keygen -R ${onmetal_ip}
    """

}


// The external code must return it's contents as an object
return this;

